use pest_derive::Parser;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::Arc;

#[derive(Parser)]
#[grammar = "grammar/config.pest"]
pub struct ConfigParser;

// Rule enum is auto-generated by pest_derive - we reference it directly
// The generated Rule will be available in this scope

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum Theme {
    Dark,
    Light,
}

impl Theme {
    #[inline]
    pub fn from_str(s: &str) -> Self {
        match s.trim().to_lowercase().as_str() {
            "light" => Theme::Light,
            _ => Theme::Dark, // Default to dark
        }
    }

    #[inline]
    pub fn to_str(self) -> &'static str {
        match self {
            Theme::Dark => "dark",
            Theme::Light => "light",
        }
    }
}

#[derive(Clone, Debug)]
pub struct Config {
    pub host_file_path: Option<Arc<Path>>,
    pub history_dir: Option<Arc<Path>>,
    pub max_history_entries: usize,
    pub theme: Theme,
}

impl Default for Config {
    #[inline]
    fn default() -> Self {
        Config {
            host_file_path: None,
            history_dir: None,
            max_history_entries: 5,
            theme: Theme::Dark,
        }
    }
}

impl Config {
    /// Load config from INI file
    #[inline]
    pub fn load_from_file(path: &Path) -> Result<Self, anyhow::Error> {
        let content = match fs::read_to_string(path) {
            Ok(content) if !content.is_empty() => content,
            _ => return Ok(Config::default()),
        };
        Self::parse_ini(&content)
    }

    /// Parse INI content into Config
    fn parse_ini(content: &str) -> Result<Self, anyhow::Error> {
        use pest::Parser;
        // Rule enum is auto-generated by pest_derive - use it directly
        // The generated Rule is available in this module scope
        let file = ConfigParser::parse(Rule::file, content)?
            .next()
            .ok_or_else(|| anyhow::anyhow!("Empty config file"))?;

        let mut config = Config::default();
        let mut current_section = "";
        let mut properties: HashMap<&str, HashMap<&str, &str>> = HashMap::new();

        for line in file.into_inner() {
            match line.as_rule() {
                Rule::section => {
                    let mut inner = line.into_inner();
                    current_section = inner.next().unwrap().as_str();
                }
                Rule::property => {
                    let mut inner = line.into_inner();
                    let key = inner.next().unwrap().as_str();
                    let value = inner.next().unwrap().as_str();

                    let section = properties.entry(current_section).or_default();
                    section.insert(key, value);
                }
                _ => {}
            }
        }

        // Parse [paths] section
        if let Some(paths) = properties.get("paths") {
            if let Some(&host_path) = paths.get("host_file_path") {
                if !host_path.is_empty() {
                    let host_path = PathBuf::from(host_path);
                    config.host_file_path = Some(host_path.as_path().into());
                }
            }
            if let Some(&history_path) = paths.get("history_dir") {
                if !history_path.is_empty() {
                    let history_path = PathBuf::from(history_path);
                    config.history_dir = Some(history_path.as_path().into());
                }
            }
            if let Some(max_entries) = paths.get("max_history_entries") {
                if let Ok(max) = max_entries.parse::<usize>() {
                    config.max_history_entries = max;
                }
            }
        }

        // Parse [appearance] section
        if let Some(appearance) = properties.get("appearance") {
            if let Some(theme_str) = appearance.get("theme") {
                config.theme = Theme::from_str(theme_str);
            }
        }

        Ok(config)
    }

    /// Serialize config to INI format
    pub fn to_ini(&self) -> String {
        let mut result = String::from("# AdBlock Manager Configuration\n\n");

        // [paths] section
        result.push_str("[paths]\n");
        if let Some(ref host_path) = self.host_file_path {
            result.push_str(&format!("host_file_path = {}\n", host_path.display()));
        }
        if let Some(ref history_path) = self.history_dir {
            result.push_str(&format!("history_dir = {}\n", history_path.display()));
        }
        result.push_str(&format!(
            "max_history_entries = {}\n\n",
            self.max_history_entries
        ));

        // [appearance] section
        result.push_str("[appearance]\n");
        result.push_str(&format!("theme = {}\n\n", self.theme.to_str()));

        result
    }

    /// Save config to file
    #[inline]
    pub fn save_to_file(&self, path: &Path) -> Result<(), anyhow::Error> {
        // Create parent directory if it doesn't exist
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::write(path, self.to_ini())?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_empty_config() {
        let config = Config::parse_ini("").unwrap();
        assert_eq!(config.max_history_entries, 50);
        assert_eq!(config.theme, Theme::Dark);
    }

    #[test]
    fn test_parse_paths_section() {
        let content = "[paths]\nhost_file_path = /etc/hosts\nhistory_dir = /tmp/history\nmax_history_entries = 100\n";
        let config = Config::parse_ini(content).unwrap();
        match config.host_file_path {
            Some(v) => assert_eq!(v.as_ref(), "/etc/hosts"),
            None => panic!("host_file_path is None"),
        }
        match config.history_dir {
            Some(v) => assert_eq!(v.as_ref(), "/tmp/history"),
            None => panic!("history_dir is None"),
        }
        assert_eq!(config.max_history_entries, 100);
    }

    #[test]
    fn test_parse_appearance_section() {
        let content = "[appearance]\ntheme = light\n";
        let config = Config::parse_ini(content).unwrap();
        assert_eq!(config.theme, Theme::Light);
    }

    #[test]
    fn test_parse_with_comments() {
        let content = "# This is a comment\n[paths]\nhost_file_path = /etc/hosts\n";
        let config = Config::parse_ini(content).unwrap();
        match config.host_file_path {
            Some(v) => assert_eq!(v.as_ref(), "/etc/hosts"),
            None => panic!("host_file_path is None"),
        }
    }

    #[test]
    fn test_serialize_config() {
        let mut config = Config::default();
        config.host_file_path = Some(PathBuf::from("/etc/hosts").as_path().into());
        config.theme = Theme::Light;

        let ini = config.to_ini();
        assert!(ini.contains("host_file_path = /etc/hosts"));
        assert!(ini.contains("theme = light"));
    }

    #[test]
    fn test_round_trip() {
        let original = Config {
            host_file_path: Some(PathBuf::from("/etc/hosts").as_path().into()),
            history_dir: Some(PathBuf::from("/tmp/history").as_path().into()),
            max_history_entries: 75,
            theme: Theme::Light,
        };

        let ini = original.to_ini();
        let parsed = Config::parse_ini(&ini).unwrap();

        assert_eq!(original.host_file_path, parsed.host_file_path);
        assert_eq!(original.history_dir, parsed.history_dir);
        assert_eq!(original.max_history_entries, parsed.max_history_entries);
        assert_eq!(original.theme, parsed.theme);
    }
}
